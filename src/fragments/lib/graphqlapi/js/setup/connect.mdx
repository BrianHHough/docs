> *This guide provides essential information to help you select and complete the activities you need for your Amplify project. We organized each section around a distinct job or decision point to help you understand your available options, steps to complete, and recommended best practices. For users who want to learn more, we included extra details and explanations in expandable sections within the guide.*


In this guide, you will learn how to connect an existing data stack to your application. This job includes understanding the required client configuration and how to connect the data stack. We will also review functions to create, read, update, and delete your data using the Amplify GraphQL client. Finally, we will look at how to subscribe to real-time events to watch for mutations in your data.

Before you begin, you will need:
- An AWS AppSync API already set up. For guidance on how to build a GraphQL API, see [Designing a GraphQL API in AWS AppSync](https://docs.aws.amazon.com/appsync/latest/devguide/designing-a-graphql-api.html)
- An application set up. For instructions on setting up an app, see [Project Setup: Create your application](https://docs.amplify.aws/lib/project-setup/create-application/q/platform/js/)
 - [npm installed](https://docs.npmjs.com/getting-started)
 - A data stack deployed

## Review the required configuration

You will need to configure your client to point to the AWS AppSync API endpoint. This includes understanding how to configure the Amplify API category and update the authentication type. Additionally, knowing the differences between authentication types can be helpful if you did not set up the data stack yourself.

### Configure the client to point to the AWS AppSync API endpoint

You can use existing AWS AppSync resources by referencing the AWS AppSync API endpoint and configuring the parameters in your app. The API URL, ID, and Key can be found in the AWS AppSync console in the Settings section. You will need to know your Authentication type to complete this step. The options for Authentication type are `API_KEY`, `AWS_IAM`, `AMAZON_COGNITO_USER_POOLS`, and `OPENID_CONNECT`.

<Accordion title='Review differences between authentication types' headingLevel='4' eyebrow='Learn more'>

The following table compares the different authentication types and their use cases. 

| **Recommended use case** | **Strategy** | **Provider** |
|---|---|---|
| Public data access where users or devices are anonymous. Anyone with the AWS AppSync API key is granted access. | [`public`]() | `apiKey` |
| Recommended for public data access in a production environment, or where unauthenticated users or devices are granted permissions using AWS IAM controls. | [`public`]() | `iam` |
| Per-user data access. Access is restricted to the "owner" of a record. Leverages `amplify add auth` Cognito user pool by default. | [`owner`]() | `userPools` / `oidc` |
| Any signed-in data access. Unlike owner-based access, **any** signed-in user has access. | [`private`]() | `userPools` / `oidc` / `iam` |
| Per-user group data access. A specific or dynamically configured group of users have access. | [`group`]() | `userPools` / `oidc` |
| Define your own custom authorization rule within a Lambda function. | [`custom`]() | `function` |

</Accordion>

<br/>

Choose your authentication type from the tabs below and configure the client by updating the following details:

<BlockSwitcher>
<Block name="API_KEY">

```javascript
const myAppConfig = {
  // ...
  aws_appsync_graphqlEndpoint:
    'https://xxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',
  aws_appsync_region: 'us-east-1',
  aws_appsync_authenticationType: 'API_KEY',
  aws_appsync_apiKey: 'da2-xxxxxxxxxxxxxxxxxxxxxxxxxx'
  // ...
};

Amplify.configure(myAppConfig);
```

</Block>
<Block name="AWS_IAM">

```javascript
const myAppConfig = {
  // ...
  aws_appsync_graphqlEndpoint:
    'https://xxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',
  aws_appsync_region: 'us-east-1',
  aws_appsync_authenticationType: 'AWS_IAM'
  // ...
};

Amplify.configure(myAppConfig);
```

</Block>
<Block name="AMAZON_COGNITO_USER_POOLS">

```javascript
const myAppConfig = {
  // ...
  aws_appsync_graphqlEndpoint:
    'https://xxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',
  aws_appsync_region: 'us-east-1',
  aws_appsync_authenticationType: 'AMAZON_COGNITO_USER_POOLS' // You have configured Auth with Amazon Cognito User Pool ID and Web Client ID
  // ...
};

Amplify.configure(myAppConfig);
```

</Block>
<Block name="OPENID_CONNECT">

To call an API that's authenticated with OpenID Connect, you need to complete 2 steps:

1. Ensure that the client configuration includes the `OPENID_CONNECT` authentication type
2. Call `Auth.federatedSignIn(...)` to sign in to an authenticated session

If sign in was successful, `call API.graphql(...)` to make your API requests.

```javascript
const myAppConfig = {
  // ...
  aws_appsync_graphqlEndpoint:
    'https://xxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',
  aws_appsync_region: 'us-east-1',
  aws_appsync_authenticationType: 'OPENID_CONNECT' // Before calling API.graphql(...) is required to do Auth.federatedSignIn(...) check authentication guide for details.
  // ...
};

Amplify.configure(myAppConfig);
```

</Block>
</BlockSwitcher>

#### Using with an AWS AppSync custom domain name

[Custom domain names](https://docs.aws.amazon.com/appsync/latest/devguide/custom-domain-name.html) can be used to create a memorable endpoint with a domain name of your choice. These can have any format, but must end with `/graphql` (see [URIs, Routes](https://graphql.org/learn/serving-over-http/#uris-routes) on the GraphQL website). Using custom domain names will impact how you enter your `graphqlEndpoint`:

```javascript
const myAppConfig = {
  // ...
  aws_appsync_graphqlEndpoint: 'https://api.yourdomain.com/graphql', // <- Provide your custom domain here
  aws_appsync_region: 'us-east-1',
  aws_appsync_authenticationType: 'API_KEY' // All auth modes are supported
  // ...
};

Amplify.configure(myAppConfig);
```

<Accordion title='Using a non-AppSync GraphQL server' headingLevel='3' eyebrow='Learn more'>

You also have the option to use a non-AppSync GraphQL server. You will need to configure the endpoint URL in your appâ€™s configuration to access a non-AppSync GraphQL API with your app. Add the following steps to your setup:

```js
import { Amplify, API } from 'aws-amplify';
import awsconfig from './aws-exports';

// Considering you have an existing aws-exports.js configuration file
Amplify.configure(awsconfig);

// Configure a custom GraphQL endpoint
Amplify.configure({
  API: {
    graphql_endpoint: 'https:/www.example.com/my-graphql-endpoint'
  }
});
```

#### Set custom request headers for non-AppSync GraphQL APIs

When working with a non-AppSync GraphQL endpoint, you may need to set request headers for authorization purposes. This is done by passing a `graphql_headers` function into the configuration:

```js
Amplify.configure({
  API: {
    graphql_headers: async () => ({
      'My-Custom-Header': 'my value'
    })
  }
});
```

#### Signing request with IAM

You can sign requests automatically with AWS Identity Access Management (IAM) for GraphQL requests that are processed through Amazon API Gateway. Add the `graphql_endpoint_iam_region` parameter to your GraphQL configuration statement to enable signing:

```js
Amplify.configure({
  API: {
    graphql_endpoint: 'https://www.example.com/my-graphql-endpoint',
    graphql_endpoint_iam_region: 'my_graphql_apigateway_region'
  }
});
```

</Accordion>

<br/>

**Recap:** At this point, your client is now configured to point to your AWS AppSync API endpoint and you updated your authentication details based on the auth types you are using. Now you're ready to call your GraphQL API.

## Connect your application code to the data backend

You will connect your application code to the data stack by connecting and configuring the Amplify Libraries. We will review how to install and configure Amplify Libraries to help you complete this task. Before starting these steps you should [review the required configuration](#Review-the-required-configuration).

[TODO]: # (Follow up on the following codegen section for better placement. May be shifted to a different section.)

### Use Amplify codegen to generate queries, mutations, and subscriptions 

Using the `amplify add codegen` command, you can add an AWS AppSync API that is created using the AWS console. If your API is in a different Region than your current Region, the command asks you to choose the Region. If you are adding codegen outside of an initialized Amplify project, provide your introspection schema named `schema.json` in the same directory that you make the add codegen call from. 

<Callout>

__Note:__ If you use the --apiId flag to add an externally created AWS AppSync API, such as one created in the AWS console, you will not be able to manage this API from the Amplify CLI with commands such as `amplify api update` when performing schema updates. You cannot add an external AWS AppSync API when outside of an initialized project.

</Callout>

```bash
amplify add codegen --apiId <apiId>
```
Executing this command will generate the queries, mutations, and subscriptions within the src/graphql folder.

### Install and configure the Amplify Libraries

Add the `aws-amplify` package to your app with `yarn` or `npm`. This is the main library for working with Amplify Libraries in your projects. This will include connecting your app with the GraphQL endpoint.

Add Amplify to your app with `yarn` or `npm`:

```bash
npm install aws-amplify @aws-amplify/ui-react
```

In your app's entry point, specifically **App.js** (Expo) or **index.js** (React Native CLI), import and load the configuration file:

```javascript
import { Amplify, API, graphqlOperation } from 'aws-amplify';
import awsconfig from './aws-exports';
Amplify.configure(awsconfig);
```

If you are using `Angular`, `NextJS`, or `VueJS`, please review the following additional details for installing the Amplify Libraries:

<BlockSwitcher>
<Block name="Angular">

Inside the `amplify-app` directory, install the Amplify Angular Library and run your app:

```bash
npm install --save aws-amplify @aws-amplify/ui-angular

npm start
```

The `@aws-amplify/ui-angular` package is a set of Angular components and an Angular provider that helps integrate your application with the AWS Amplify Library.

<Callout>

**Angular CLI output warnings:** If you encounter optimization bailouts warnings using Angular 9+ due to CommonJS or AMD dependencies, you can use this [gist](https://gist.github.com/wlee221/6d98d96740bea6f53327b4db4a432616) to remove them. See the [Angular website](https://angular.io/guide/build#configuring-commonjs-dependencies) for more details.

</Callout>

##### Strictly typing `aws-exports`

If you have TypeScript [strict mode](https://www.typescriptlang.org/tsconfig/#strict) on and see the error

```
Could not find a declaration file for module './aws-exports'. 'aws-exports.js' implicitly has an 'any' type.
```

Create a `aws-exports.d.ts` file on the same level as `aws-exports` with the following content:

```ts
declare const awsmobile: Record<string, any>
export default awsmobile;
```

##### Importing the Amplify Angular UI Module

Add the **Amplify Authenticator UI Module** to `src/app/app.module.ts`:

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AmplifyAuthenticatorModule } from '@aws-amplify/ui-angular';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    /* configure App with AmplifyAuthenticatorModule */
    AmplifyAuthenticatorModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

</Block>

<Block name="NextJS">

The first step to using Amplify in the client for NextJS is to install the necessary dependencies:

```bash
npm install aws-amplify @aws-amplify/ui-react
```

The `aws-amplify` package is the main library for working with Amplify in your apps. The `@aws-amplify/ui-react` package includes React-specific UI components that you can use to build your app UI. To learn more about Amplify UI, visit our [documentation](https://ui.docs.amplify.aws/).

</Block>

<Block name="VueJS">

The first step to using Amplify in the client for VueJS is to install the necessary dependencies:

<Block name="NPM">

```
npm install aws-amplify @aws-amplify/ui-vue
```

</Block>

<Callout>

If you are using Vue 2, please check out our legacy [documentation](https://github.com/aws-amplify/amplify-ui/tree/legacy/legacy/amplify-ui-vue). For Vite installs, check out this [documentation](https://ui.docs.amplify.aws/vue/getting-started/installation#vite). 

</Callout>

The `@aws-amplify/ui-vue` package is a set of components that make it easy to integrate functionality, such as end-to-end authentication flows.

</Block>
</BlockSwitcher>

**Recap:** Well done! You now have your Amplify Libraries set up and configured. 

## Create, update, and delete application data

In this job, you will run mutations to create, update, and delete application data. We will also show you how to cancel these requests. Before you begin, you will need your application connected to the API.

### Run mutations to create, update, and delete application data
  
In GraphQL, mutations write data to the API and are used to create, update, or delete data. This is different than queries that allow you to read the data but not change it. What follows are some examples of how you can create, update, and delete items using the Amplify GraphQL client.

#### Create an item
You can create an item by first importing the API and mutations. Then you can add an item:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';
import { GraphQLQuery } from '@aws-amplify/api';
import { CreateTodoInput, CreateTodoMutation } from './API';

const todoDetails: CreateTodoInput = {
  name: 'Todo 1',
  description: 'Learn AWS AppSync'
};

const newTodo = await API.graphql<GraphQLQuery<CreateTodoMutation>>({ 
  query: mutations.createTodo, 
  variables: { input: todoDetails }
});
```

You should see the item created: `Learn AWS AppSync`.

</Block>

<Block name="JavaScript">

```js
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';

const todoDetails = {
  name: 'Todo 1',
  description: 'Learn AWS AppSync'
};

const newTodo = await API.graphql({ 
  query: mutations.createTodo, 
  variables: { input: todoDetails }
});
```

You should see the item created: `Learn AWS AppSync`.

</Block>

</BlockSwitcher>

<Callout>

__Note:__ You do not have to pass in the `createdAt` field. AWS AppSync manages this for you.

</Callout>

You can also import the `graphqlOperation` helper function to help you construct the argument object:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { API, graphqlOperation } from 'aws-amplify';

// equivalent to above example
const newTodo = await API.graphql<GraphQLQuery<CreateTodoMutation>>(
  graphqlOperation(mutations.createTodo, { input: todoDetails })
);
```

</Block>

<Block name="JavaScript">

```js
// ...
import { API, graphqlOperation } from 'aws-amplify';

// equivalent to above example
const newTodo = await API.graphql(
  graphqlOperation(mutations.createTodo, { input: todoDetails })
);
```

</Block>
</BlockSwitcher>

#### Update an item

To update the item, use the GraphQL update mutation:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';
import { GraphQLQuery } from '@aws-amplify/api';
import { UpdateTodoInput, UpdateTodoMutation } from './API';

const todoDetails: UpdateTodoInput = {
  id: 'some_id',
  description: 'Updated description'
};

const updatedTodo = await API.graphql<GraphQLQuery<UpdateTodoMutation>>({ 
  query: mutations.updateTodo, 
  variables: { input: todoDetails }
});
```

</Block>

<Block name="JavaScript">

```js
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';

const todoDetails = {
  id: 'some_id',
//  _version: 'current_version', // add the "_version" field if your AppSync API has conflict detection (required for DataStore) enabled
  description: 'Updated description'
};

const updatedTodo = await API.graphql({ 
  query: mutations.updateTodo, 
  variables: { input: todoDetails }
});
```

</Block>

</BlockSwitcher>

<Callout>

__Notes:__

- You do not have to pass in the `updatedAt` field. AWS AppSync manages this for you.
- If you pass in *extra* input fields not expected by the AWS AppSync schema, this query will fail. You can see this in the `error` field returned by the query. In GraphQL, errors are not thrown like exceptions in other languages. Instead, any errors are captured and returned as part of the query result in the `error` field.

</Callout>

#### Delete an item

You can then delete the Todo by using the delete mutation. Only an `id` is needed to identify which item to delete:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';
import { GraphQLQuery } from '@aws-amplify/api';
import { DeleteTodoInput, DeleteTodoMutation } from './API';

const todoDetails: DeleteTodoInput = {
  id: 'some_id',
};

const deletedTodo = await API.graphql<GraphQLQuery<DeleteTodoMutation>>({ 
  query: mutations.deleteTodo, 
  variables: { input: todoDetails }
});
```

</Block>

<Block name="JavaScript">

```js
import { API } from "aws-amplify";
import * as mutations from './graphql/mutations';

const todoDetails = {
  id: 'some_id',
};

const deletedTodo = await API.graphql({ 
  query: mutations.deleteTodo, 
  variables: { input: todoDetails }
});
```

</Block>

</BlockSwitcher>

<Callout>

__Note:__ Join table records must be deleted prior to deleting the associated records. For example, for a many-to-many relationship between Posts and Tags, delete the PostTags join record prior to deleting a Post or Tag.

</Callout>

[TODO]: # (Follow up on troubleshooting Q. We had a note to provide troubleshooting for unauthorized errors and cross-platform gotchas - do we still want to add an expander with this troubleshooting guidance?)

<Accordion title='Custom authorization mode to mutate data' headingLevel='4' eyebrow='Learn more'>

Each AWS AppSync API uses a default authorization mode when you configure your app. To override this default, pass an `authMode` property. The following examples show how you can mutate data with custom authorization mode:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from "aws-amplify";
import { GraphQLQuery, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as mutations from './graphql/mutations';
import { CreateTodoInput, CreateTodoMutation } from './API';

const todoDetails: CreateTodoInput = {
  id: 'some_id',
  name: 'My todo!',
  description: 'Hello world!'
};

const todo = await API.graphql<GraphQLQuery<CreateTodoMutation>>({
  query: mutations.createTodo,
  variables: { input: todoDetails },
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>

<Block name="JavaScript">

```js
import { API } from "aws-amplify";
import { GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as mutations from './graphql/mutations';

const todoDetails = {
  id: 'some_id',
  name: 'My todo!',
  description: 'Hello world!'
};

const todo = await API.graphql({
  query: mutations.createTodo,
  variables: { input: todoDetails },
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>
</BlockSwitcher>

</Accordion>

[TODO]: # (We should review where else this fragment is used and see if we want to change this and put it in the docs. It would mean we can make the paragraph more consistent and just replace code for other frameworks. This sample comes from https://github.com/aws-amplify/docs/blob/main/src/fragments/lib/graphqlapi/js/cancel-request.mdx)

### Cancel mutation requests

You can cancel any GraphQL API request calling `.cancel` on the GraphQL request promise that's returned by `API.graphql(...)`.

```javascript
const promise = API.graphql(graphqlOperation(...));

try {
  await promise;
} catch (error) {
  console.log(error);
  // If the error is because the request was cancelled you can confirm here.
  if (API.isCancel(error)) {
    console.log(error.message); // "my message for cancellation"
    // handle user cancellation logic
  }
}

...

// To cancel the above request
API.cancel(promise, "my message for cancellation");
```

You need to ensure that the promise returned from `API.graphql()` has not been modified. Typically, async functions wrap the promise being returned into another promise. For example, the following will not work:

```javascript
async function makeAPICall() {
  return API.graphql(graphqlOperation(...));
}
const promise = makeAPICall();

// The following will NOT cancel the request.
API.cancel(promise, "my error message");
```

**Recap:** You are now able to create, update, and delete your app data via the GraphQL API. 

## Read application data

You can read application data using the Amplify GraphQL client. In this next section we will review the difference between listing data and getting data, how to filter query results to get just the data you need, and how to paginate results to make you're data more manageable. We will also show you how to cancel these requests when needed. Before you begin you will need your application connected to the API and some populated data to query.

### Read and filter your data
  
Queries are used to read data from the API and include the `List` and `Get` operations.
  
You can use both `List` and `Get` to query data in GraphQL. A `List` will get you a record of several items, such as Todo items, and does not require an ID. This is best suited for getting an overview or summary of items or can help when filtering by specific criteria across a list of items. When you want to query a single entry by ID, you would use `Get` to retrieve a specific Todo item.

<Callout>

__Note:__ The cost structure of your underlying data source can impact the cost to run some queries. For example, the `List` operation uses "scan operations" which uses more read request units than the `Get` operation. You will want to review the associated costs for these operations for your data source. In our example case here we are using Amazon DynamoDB and you can [learn more about how DynamoDB pricing is calculated](https://aws.amazon.com/dynamodb/pricing/) on their site.

</Callout>

[TODO]: # (Follow up on the following codegen section for better placement. May be shifted to a different section.)

The Amplify CLI's codegen automatically creates code for all possible GraphQL operationsâ€”mutations, queries, and subscriptions. For JavaScript applications, this generated code is saved in the src/graphql folder. 

```javascript
import * as queries from './graphql/queries';
import * as mutations from './graphql/mutations';
import * as subscriptions from './graphql/subscriptions';
```

To run a GraphQL query, import the generated query and run it with `API.graphql`:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from 'aws-amplify';
import * as queries from './graphql/queries';
import { GraphQLQuery } from '@aws-amplify/api';
import { ListTodosQuery, GetTodoQuery } from './API';

// Simple query
const allTodos = await API.graphql<GraphQLQuery<ListTodosQuery>>(
  { query: queries.listTodos }
);
console.log(allTodos); // result: { "data": { "listTodos": { "items": [/* ..... */] } } }

// Fetch a single record by its identifier
const oneTodo = await API.graphql<GraphQLQuery<GetTodoQuery>>({
  query: queries.getTodo,
  variables: { id: 'some id' }
});
```

</Block>

<Block name="JavaScript">

```js
import { API } from 'aws-amplify';
import * as queries from './graphql/queries';

// Simple query
const allTodos = await API.graphql({ query: queries.listTodos });
console.log(allTodos); // result: { "data": { "listTodos": { "items": [/* ..... */] } } }

//Fetch a single record by its identifier
const oneTodo = await API.graphql({
  query: queries.getTodo,
  variables: { id: 'some id' }
});
```

</Block>

</BlockSwitcher>

You can optionally import the `graphqlOperation` helper function to help you construct this argument object:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API, graphqlOperation } from 'aws-amplify';
import { GraphQLQuery } from '@aws-amplify/api';
import { GetTodoQuery } from './API';
// ...

const oneTodo = await API.graphql<GraphQLQuery<GetTodoQuery>>(
  graphqlOperation(queries.getTodo, { id: 'some id' })
);
```

</Block>

<Block name="JavaScript">

```js
import { API, graphqlOperation } from 'aws-amplify';
// ...

const oneTodo = await API.graphql(
  graphqlOperation(queries.getTodo, { id: 'some id' })
);
```

</Block>
</BlockSwitcher>

<Accordion title='Troubleshooting deny-by-default behavior' headingLevel='4' eyebrow='Troubleshooting'>

You can run into unauthorized errors if you do not have at least one auth rule defined. 

Use the `@auth` directive to configure authorization rules for public, sign-in user, per user, and per user group data access. **Authorization rules operate on the deny-by-default principle**. Meaning that if an authorization rule is not specifically configured, it is denied.

```graphql
type Todo @model @auth(rules: [{ allow: owner }]) {
  content: String
}
```

In the example above, each signed-in user, or also known as "owner", of a Todo can create, read, update, and delete their own Todos.

Amplify also allows you to restrict the allowed operations, combine multiple authorization rules, and apply fine-grained field-level authorization.

``` graphql
type Todo @model @auth(rules: [
  { allow: public, operations: [read]},
  { allow: owner }
]) {
  content: String
}
```

In the example above, everyone (`public`) can read every Todo but owner (authenticated users) can create, read, update, and delete their own Todos.

To learn more, see the [Authorization Rules for the API](https://docs.amplify.aws/cli/graphql/authorization-rules/).

</Accordion>

<br/>

<Accordion title='Custom authorization mode to query data' headingLevel='4' eyebrow='Learn more'>

Each AWS AppSync API uses a default authorization mode when you configure your app. To override this default, pass an `authMode` property. For example, this is useful when you have public reads through API Key auth and authenticated reads through IAM auth. The following examples show how you can query data with custom authorization mode:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API } from 'aws-amplify';
import { GraphQLQuery, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as queries from './graphql/queries';
import { GetTodoQuery } from './API';

const todos = await API.graphql<GraphQLQuery<GetTodoQuery>>({
  query: queries.listTodos,
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>

<Block name="JavaScript">

```js
import { API } from 'aws-amplify';
import { GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as queries from './graphql/queries';


const todos = await API.graphql({
  query: queries.listTodos,
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>
</BlockSwitcher>

</Accordion>

### Paginate your data
  
As your data grows, you will want to filter and paginate at the AWS AppSync level instead of on the client. Fortunately, this is already built in to `API.graphql`, but you need to understand the schema of these queries. This is explained in the [AWS AppSync docs](https://docs.aws.amazon.com/appsync/latest/devguide/using-your-api.html), but here you will translate them to the `API.graphql` equivalent.

You can find the input schemas in the Docs pane of the GraphQL explorer or inside your autogenerated `/graphql` folder. They look like this:

```graphql
listTodos(
  filter: ModelTodoFilterInput
  limit: Int
  nextToken: String): ModelTodoConnection

input ModelTodoFilterInput {
	id: ModelIDInput
	priority: ModelIntInput
	# ... all your other Todo fields here
	and: [ModelTodoFilterInput]
	or: [ModelTodoFilterInput]
	not: ModelTodoFilterInput
}
```

#### Filtering queries

The input types in your schema indicate what kinds of filtering you can perform on them. For example, an integer field like `ModelIntInput` has this schema:

```graphql
input ModelIntInput {
  ne: Int # "not equal to"
  eq: Int # "equal to"
  le: Int # "less than or equal to"
  lt: Int # "less than"
  ge: Int # "greater than or equal to"
  gt: Int # "greater than"
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}
```

These vary based on the type of the field, but are linked to corresponding [Amazon DynamoDB queries](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html).

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { ListTodosQueryVariables, ListTodosQuery } from './API';

const variables: ListTodosQueryVariables = {
  filter: {
    priority: {
      eq: 1
    }
  }
};

await API.graphql<GraphQLQuery<ListTodosQuery>>({ 
  query: listTodos, variables: variables 
});
```

</Block>

<Block name="JavaScript">

```js
const variables = {
  filter: {
    priority: {
      eq: 1
    }
  }
};

await API.graphql({ 
  query: listTodos, variables: variables 
});;
```

</Block>
</BlockSwitcher>

##### Compound filters

You can combine filters with `and`, `or`, and `not` Boolean logic. Observe, in the autogenerated schema above, that `ModelTodoFilterInput` is recursive in respect to those fields. So if, for example, you wanted to filter for `priority` values of 1 OR 2, you would do this:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { ListTodosQueryVariables, ListTodosQuery } from './API';

const variables: ListTodosQueryVariables = {
  filter: {
    or: [
      { priority: { eq:1 } },
      { priority: { eq:2 } }
    ]
  }
};

await API.graphql<GraphQLQuery<ListTodosQuery>>({ 
  query: listTodos, variables: variables 
});
```

</Block>

<Block name="JavaScript">

```js
const variables = {
  filter: {
    or: [
      { priority: { eq:1 } },
      { priority: { eq:2 } }
    ]
  }
};

await API.graphql({ 
  query: listTodos, variables: variables 
});;
```

</Block>
</BlockSwitcher>

Note that querying for `priority` of 1 and 2 would return no results, because this is Boolean logic instead of natural language.

#### Paginating queries

To paginate results in AWS AppSync, make a query request specifying the `nextToken` field in the selection set and by passing in a `limit` input variable. The `limit` input variable limits how many results are returned. The response will include a `nextToken` you can use to request the next page of data. A `nextToken` is a very long string that represents the cursor to the starting item of the next query made with these filters.

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { ListTodosQueryVariables, ListTodosQuery } from './API';

// Fetch first 20 records
const variables: ListTodosQueryVariables = {
  limit: 20, 
  // add filter as needed
};

const res = await API.graphql<GraphQLQuery<ListTodosQuery>({ 
  query: listTodos, variables: variables
});

const { items: itemsPage1, nextToken } = res.data?.listTodos;

// Fetch the next 20 records
variables.nextToken = nextToken;

const res = await API.graphql<GraphQLQuery<ListTodosQuery>({ 
  query: listTodos, variables: variables 
});

const { items: itemsPage2 } = res.data?.listTodos;
```

</Block>

<Block name="JavaScript">

```js
// Fetch first 20 records
const variables = {
  limit: 20, 
  // add filter as needed
};

const res = await API.graphql({ 
  query: listTodos, variables: variables
});

const { items: itemsPage1, nextToken } = res.data.listTodos;

// Fetch the next 20 records
variables.nextToken = nextToken;

const res = await API.graphql({ 
  query: listTodos, variables: variables
});

const { items: itemsPage2 } = res.data.listTodos;
```

</Block>
</BlockSwitcher>

<Accordion title='Implement pagination in your GraphQL API' headingLevel='3' eyebrow='Walkthrough'>

This brief walkthrough provides additional step-by-step guidance for implementing pagination. 

When working with a large record set, you may want to only fetch the first __N__ number of items. For example, let's start with a basic GraphQL schema for a Todo app:

```graphql
type Todo @model {
  id: ID!
  title: String!
  description: String 
}
```

When the API is created with an `@model` directive, the following queries will automatically be created for you:

```graphql
type Query {
  getTodo(id: ID!): Todo
  listTodos(filter: ModelTodoFilterInput, limit: Int, nextToken: String): ModelTodoConnection
}
```

Next, take a look at the `ModelTodoConnection` type to get an idea of the data that will be returned when the `listTodos` query is run:

```graphql
type ModelTodoConnection {
  items: [Todo]
  nextToken: String
}
```

When querying the API using the `listTodos` query, the return type will be of `ModelTodoConnection`, meaning you can return both an array of `Todos` and a `nextToken`.

The `nextToken` is what is used to handle pagination. If the `nextToken` is `null`, that means that there is no more data to return from the API. If the `nextToken` is present, you can use the value as an argument to the next `listTodos` query to return the next selection set from the API.

To test this out, try creating 5 Todos using a mutation like this:

```sh
mutation createTodo {
  createTodo(input: {
    title: "Todo 1"
    description: "My first todo"
  }) {
    id
    title
    description
  }
}
```

Next, you can set the limit of the number of Todos in a query by passing in a `limit` argument. In this query, you'll set the limit to 2 items and request a `nextToken` as a return value:

```graphql
query listTodos {
  listTodos(limit: 2) {
    items {
      id
      title
      description
    }
    nextToken
  }
}
```

 Now, to query the next 2 items from the API, you can pass this `nextToken` as the argument:

```graphql
query listTodos {
  listTodos(limit: 2, nextToken: <your_token>) {
    items {
      id
      title
      description
    }
    nextToken
  }
}
```

When there are no other items left to be returned, the `nextToken` in the response will be set to null.

##### Querying from a JavaScript application

The `listTodos` query should have been created for you automatically by the CLI, but for reference purposes it should look something like this:

```js
const listTodos = `
  query listTodos($limit: Int) {
    listTodos(limit: $limit) {
      items {
        id
        title
        description
      }
      nextToken
    }
  }
`
```

To pass in a `limit` in a query from a JavaScript application, you can use the following code by setting the limit as a variable:

```js
import { API } from 'aws-amplify';

async function fetchTodos() {
  const todoData = await API.graphql({
    query: listTodos,
    variables: {
      limit: 2
    }
  })
  console.log({ todoData })
}
```

The data returned from the API request should look like this (with the items array containing however many items have been created):

```graphql
{
  "data" {
    "listTodos" {
      "items": [{ id: "001", title: "Todo 1", description: "My first todo" }],
      "nextToken": "<token-id>"
    }
  }
}
```

To set the `nextToken` in a query from a JavaScript application, you can use the following code:

```js
import { API } from 'aws-amplify';

async function fetchTodos() {
  const todoData = await API.graphql({
    query: listTodos,
    variables: {
      limit: 2,
      nextToken: "<token-id>"
    }
  })
  console.log({ todoData })
}
```

</Accordion>

<br/>

<Callout>

__Limitations:__
- There is no API to get a total page count at this time. Note that scanning all items is a [potentially expensive operation](https://github.com/aws-amplify/amplify-js/issues/2901).
- Sorting is [available in DataStore](https://docs.amplify.aws/lib/datastore/data-access/q/platform/js#predicates) but not in AWS AppSync.
- AWS AppSync schemas do not follow the edges/nodes of the [Relay spec](https://relay.dev/docs/guides/graphql-server-specification) but are spiritually similar.
- You [cannot query by `page` number](https://github.com/aws-amplify/amplify-cli/issues/5086), you have to query by `nextToken`.

</Callout>

[TODO]: # (We should review where else this fragment is used and see if we want to change this and put it in the docs. It would mean we can make the paragraph more consistent and just replace code for other frameworks. This sample comes from https://github.com/aws-amplify/docs/blob/main/src/fragments/lib/graphqlapi/js/cancel-request.mdx)

### Cancel read requests

You may cancel any query or mutation request made through the API category by keeping a reference to the promise returned.

```javascript
const promise = API.graphql(graphqlOperation(...));

try {
  await promise;
} catch (error) {
  console.log(error);
  // If the error is because the request was cancelled you can confirm here.
  if (API.isCancel(error)) {
    console.log(error.message); // "my message for cancellation"
    // handle user cancellation logic
  }
}

...

// To cancel the above request
API.cancel(promise, "my message for cancellation");
```

You need to ensure that the promise returned from `API.graphql()` has not been modified. Typically, async functions wrap the promise being returned into another promise. For example, the following will not work:

```javascript
async function makeAPICall() {
  return API.graphql(graphqlOperation(...));
}
const promise = makeAPICall();

// The following will NOT cancel the request.
API.cancel(promise, "my error message");
```

**Recap:** You now have an understanding of how to read your data through `Get` and `List` queries. 

## Subscribe to real-time events

In the section below we outline the benefits of enabling real-time data integrations and how to set up and filter these subscriptions. We will also cover how to unsubscribe from subscriptions when needed. Before you begin you will need your application connected to the API and populated data to modify.

### Set up a real-time subscription

Subscriptions is a GraphQL feature that allows the server to send data to its clients when a specific event happens. You can enable real-time data integration in your app with a subscription.

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Amplify, API, graphqlOperation } from 'aws-amplify';
import { GraphQLSubscription } from '@aws-amplify/api';
import * as subscriptions from './graphql/subscriptions';
import { OnCreateTodoSubscription,OnUpdateTodoSubscription,OnDeleteTodoSubscription } from './API';

// Subscribe to creation of Todo
const sub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Subscribe to update of Todo
const updateSub = API.graphql<GraphQLSubscription<OnUpdateTodoSubscription>>(
  graphqlOperation(subscriptions.onUpdateTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Subscribe to deletion of Todo
const deleteSub = API.graphql<GraphQLSubscription<OnDeleteTodoSubscription>>(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});
// Stop receiving data updates from the subscription
sub.unsubscribe();
```

</Block>

<Block name="JavaScript">

```js
import { Amplify, API, graphqlOperation } from 'aws-amplify';
import * as subscriptions from './graphql/subscriptions';

// Subscribe to creation of Todo
const sub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Subscribe to update of Todo
const updateSub = API.graphql(
   graphqlOperation(subscriptions.onUpdateTodo)
  ).subscribe({
    next: ({ provider, value }) => console.log({ provider, value }),
    error: (error) => console.warn(error)
  });

// Subscribe to deletion of Todo
const deleteSub = API.graphql(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Stop receiving data updates from the subscription
sub.unsubscribe();
```

</Block>
</BlockSwitcher>

When using **AWS AppSync** subscriptions, be sure that your AWS AppSync configuration is at the root of the configuration object, instead of being under the API:

```javascript
Amplify.configure({
  Auth: {
    identityPoolId: 'xxx',
    region: 'xxx',
    cookieStorage: {
      domain: 'xxx',
      path: 'xxx',
      secure: true
    }
  },
  aws_appsync_graphqlEndpoint: 'xxxx',
  aws_appsync_region: 'xxxx',
  aws_appsync_authenticationType: 'xxxx',
  aws_appsync_apiKey: 'xxxx'
});
```

Subscriptions take an optional `filter` argument to define service-side subscription filters:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { GraphQLSubscription } from '@aws-amplify/api';
import { OnCreateTodoSubscriptionVariables, OnCreateTodoSubscription } from './API';

const variables: OnCreateTodoSubscriptionVariables = {
  filter: {
    // Only receive Todo messages where the "type" field is "Personal"
    type: { eq: "Personal" }
  }
}

const sub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo, variables)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: error => console.warn(error)
});
```

</Block>

<Block name="JavaScript">

```js
// ...

const variables = {
  filter: {
    // Only receive Todo messages where the "type" field is "Personal"
    type: { eq: "Personal" }
  }
}

const sub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo, variables)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: error => console.warn(error)
});
```

</Block>
</BlockSwitcher>

If you want to get all subscription events, donâ€™t pass any `filter` parameters.

<Callout>

__Limitations:__
- Passing an empty object `{}` as a filter is **not** recommended. Using `{}` as a filter might cause inconsistent behavior based on your data model's authorization rules.
- If you are using dynamic group authorization and you authorize based on a single group per record, then subscriptions are only supported if the user is part of 5 or fewer user groups.
- Additionally, if you authorize via an array of groups (groups: [String]),
  - subscriptions are only supported if the user is part of 20 or fewer groups
  - you can only authorize 20 or fewer user groups per record

</Callout>

#### Subscription connection status updates

Now that your application is set up and using subscriptions, you may want to know when the subscription is finally established, or reflect to your users when the subscription isn't healthy. You can monitor the connection state for changes through the `Hub` local eventing system.

```ts
import { CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/pubsub';
import { Hub } from 'aws-amplify';

Hub.listen('api', (data: any) => {
  const { payload } = data;
  if (payload.event === CONNECTION_STATE_CHANGE) {
    const connectionState = payload.data.connectionState as ConnectionState;
    console.log(connectionState);
  }
});
```

##### Connection states

- **`Connected`** - Connected and working with no issues.
- **`ConnectedPendingDisconnect`** - The connection has no active subscriptions and is disconnecting.
- **`ConnectedPendingKeepAlive`** - The connection is open, but has missed expected keep-alive messages.
- **`ConnectedPendingNetwork`** - The connection is open, but the network connection has been disrupted. When the network recovers, the connection will continue serving traffic.
- **`Connecting`** - Attempting to connect.
- **`ConnectionDisrupted`** - The connection is disrupted and the network is available.
- **`ConnectionDisruptedPendingNetwork`** - The connection is disrupted and the network connection is unavailable.
- **`Disconnected`** - Connection has no active subscriptions and is disconnecting.

<Accordion title='Troubleshooting connection issues and automated reconnection' headingLevel='4' eyebrow='Troubleshooting'>

Connections between your application and backend subscriptions can be interrupted for various reasons, including network outages or the device entering sleep mode. Your subscriptions will automatically reconnect when it becomes possible to do so.

While offline, your application will miss messages and will not automatically catch up when reconnection happens. Depending on your use case, you may want to take action for your app to catch up when it comes back online.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { GraphQLQuery, GraphQLSubscription } from '@aws-amplify/api';
import {
  ListTodosQuery
  OnCreateTodoSubscription,
  OnUpdateTodoSubscription,
  OnDeleteTodoSubscription
} from './API';

const fetchRecentData = () => {
  // Retrieve some/all data from AppSync
  const allTodos = await API.graphql<GraphQLQuery<ListTodosQuery>>({ 
    query: queries.listTodos 
  });
}

let priorConnectionState: ConnectionState;

Hub.listen("api", (data: any) => {
  const { payload } = data;
  if (
    payload.event === CONNECTION_STATE_CHANGE
  ) {

    if (priorConnectionState === ConnectionState.Connecting && payload.data.connectionState === ConnectionState.Connected) {
      fetchRecentData();
    }
    priorConnectionState = payload.data.connectionState;
  }
});

const createSub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const updateSub = API.graphql<GraphQLSubscription<OnUpdateTodoSubscription>>(
  graphqlOperation(subscriptions.onUpdateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const deleteSub = API.graphql<GraphQLSubscription<OnDeleteTodoSubscription>>(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: data => // Process incoming messages
});

const cleanupSubscriptions = () => {
  createSub.unsubscribe();
  updateSub.unsubscribe();
  deleteSub.unsubscribe();
}
```

</Block>

<Block name="JavaScript">

```js
// ...

const fetchRecentData = () => {
  // Retrieve some/all data from AppSync
  const allTodos = await API.graphql({ query: queries.listTodos });
}

let priorConnectionState: ConnectionState;

Hub.listen("api", (data: any) => {
  const { payload } = data;
  if (
    payload.event === CONNECTION_STATE_CHANGE
  ) {

    if (priorConnectionState === ConnectionState.Connecting && payload.data.connectionState === ConnectionState.Connected) {
      fetchRecentData();
    }
    priorConnectionState = payload.data.connectionState;
  }
});

const createSub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const updateSub = API.graphql(
  graphqlOperation(subscriptions.onUpdateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const deleteSub = API.graphql(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: data => // Process incoming messages
});

const cleanupSubscriptions = () => {
  createSub.unsubscribe();
  updateSub.unsubscribe();
  deleteSub.unsubscribe();
}
```

</Block>
</BlockSwitcher>

</Accordion>

<br/>

[TODO]: # (Reminder that in last review noted opportunity to reduce this into a short blurb and move the main content to "custom business logic")

<Accordion title='Create a custom GraphQL subscription by ID' headingLevel='4' eyebrow='Walkthrough'>

This brief walkthrough provides additional step-by-step guidance for creating a custom GraphQL subscription that will only be connected and triggered by a mutation containing a specific ID as an argument.

When using the Amplify GraphQL transform library, there will often be times when you need to expand the GraphQL schema and operations created by the `@model` directive. A common use case is when fine grained control is needed for GraphQL subscriptions.

Take for example the following GraphQL schema:

```graphql
type Post @model @auth(rules: [{ allow: public, provider: apiKey }]){
  id: ID!
  title: String!
  content: String
  comments: [Comment] @hasMany
}

type Comment @model @auth(rules: [{ allow: public, provider: apiKey }]){
  id: ID!
  content: String
}
```

By default, subscriptions will be created for the following mutations:

```graphql
# Post type
onCreatePost
onUpdatePost
onDeletePost

# Comment type
onCreateComment
onUpdateComment
onDeleteComment
```

One operation that is not covered is if you wanted to only subscribe to comments for a specific post.

Because the schema has a one to many relationship enabled between posts and comments, you can use the auto-generated field `postCommentsId` that defines the relationship between the post and the comment to set this up in a new Subscription definition.

To implement this, you could update the schema with the following:

```graphql
type Post @model @auth(rules: [{ allow: public, provider: apiKey }]){
  id: ID!
  title: String!
  content: String
  comments: [Comment] @hasMany
}

type Comment @model @auth(rules: [{ allow: public, provider: apiKey }]){
  id: ID!
  content: String
  postCommentsId: ID!
}

type Subscription {
  onCommentByPostId(postCommentsId: ID!): Comment
    @aws_subscribe(mutations: ["createComment"])
}

```

Now you can create a custom subscription for comment creation with a specific post id:

```js
import { API } from 'aws-amplify';
import { onCommentByPostId } from './graphql/subscriptions';

API.graphql({
  query: onCommentByPostId,
  variables: {
    postCommentsId: "12345"
  }
})
.subscribe({
  next: data => {
    console.log('data: ', data)
  }
})
```

</Accordion>

### Unsubscribe from a subscription

You can also unsubscribe from events by using subscriptions by implementing the following:

```ts
// Stop receiving data updates from the subscription
sub.unsubscribe();
```

**Recap:** You now have set up subscriptions for real-time events and understand how to filter and cancel these subscriptions when needed.

## Conclusion

Congratulations! You have finished the **Connect a data stack** guide. In this guide, you installed and configured Amplify Libraries; used GraphQL mutations for app data requests; filtered app data in Amplify; and set up, filtered, and canceled subscriptions for real-time events.

## Next steps

Our recommended next steps include continuing to build out and customize your information architecture for your data. Some resources that will help with this work include:
  - [Authorization Rules](https://docs.amplify.aws/cli/graphql/authorization-rules/)
  - [Data Modeling](https://docs.amplify.aws/cli/graphql/data-modeling/)
  - [Custom Business Logic](https://docs.amplify.aws/cli/graphql/custom-business-logic/)